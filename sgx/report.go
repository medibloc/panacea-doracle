package sgx

import (
	"bytes"
	"encoding/binary"
	"encoding/hex"
	"fmt"
	"github.com/edgelesssys/ego/enclave"
)

const (
	promisedMinSecurityVersion = 1
	promisedProductID          = 1
	promisedSignerID           = "4599f78a9d3ee36ab0fb74801bcbe194c2c4e1b83e6947fcc962e915f5c875d6"
)

// GenerateRemoteReport generates a SGX report containing the specified data for use in remote attestation.
// This works only in the SGX-FLC environment where the SGX quote provider is installed.
func GenerateRemoteReport(data []byte, enclaveEnabled bool) ([]byte, error) {
	if enclaveEnabled {
		return enclave.GetRemoteReport(data)
	} else {
		return nil, nil
	}
}

// VerifyRemoteReport verifies whether the report not only was properly generated in the SGX environment,
// but also contains the promised security version, product ID, unique ID and signer ID,
// in order to verify that the report was generated by the promised binary which was not forged.
func VerifyRemoteReport(reportBytes, expectedData []byte, expectedUniqueID string) error {
	report, err := enclave.VerifyRemoteReport(reportBytes)
	// TODO
	// if err == attestation.ErrTCBLevelInvalid {
	// 	fmt.Printf("Warning: TCB level is invalid: %v\n%v\n", report.TCBStatus, tcbstatus.Explain(report.TCBStatus))
	// 	fmt.Println("We'll ignore this issue in this sample. For an app that should run in production, you must decide which of the different TCBStatus values are acceptable for you to continue.")
	// }
	if err != nil {
		return fmt.Errorf("failed to verify report: %w", err)
	}

	if report.SecurityVersion < promisedMinSecurityVersion {
		return fmt.Errorf("invalid security version in the report")
	}
	if binary.LittleEndian.Uint16(report.ProductID) != promisedProductID {
		return fmt.Errorf("invalid product ID in the report")
	}
	if hex.EncodeToString(report.SignerID) != promisedSignerID {
		return fmt.Errorf("invalid signer ID in the report")
	}
	// TODO: how to encode the unique id for verification?
	if hex.EncodeToString(report.UniqueID) != expectedUniqueID {
		return fmt.Errorf("invalid unique ID in the report")
	}
	if !bytes.Equal(report.Data[:len(expectedData)], expectedData) {
		return fmt.Errorf("invalid data in the report")
	}

	return nil
}
